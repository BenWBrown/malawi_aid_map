<!DOCTYPE html>
<!-- Code adapted from: http://leafletjs.com/examples/choropleth.html -->
<!-- TODO LIST:
  d3/html info panel
    locator/context map
  ++sql.js

  TODO 4/28:
  UI for info panel ===> barebones done but ugly
  choropleth symbology (normalized by population) ===> need sql statements
    geojson ordered alphabetically to avoid text matching
  filter data ===> need sql?
  context map ===> barebones done but ugly
  tooltip - district/ta name + proj number (use leaflet labels. copy code out provmap) ===> ran out of time :(
  asynch db query (?)
  loading indictors (?)

  don't get geometry out of db, dont get data out.
  think about ordering instead of doing text matching
  filter by donor, type, time

  TODO:
  COMMENTS THEN AESTHETICS
-->
<html>

  <head>
    <!--TODO?: DOWNLOAD-->
  	<link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.css" />
    <script src="leaflet.js"></script>
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script src='js/sql.js'></script>

    <style>
    #map {
      width: 600px;
      height: 600px;
      float: left;
      margin-top:10px;
    }

    #dataPanel{
      width: 400px;
      height: 600px;
      float:left;
      background-color: #ededed;
      margin-left: 25px;
      margin-right: 25px;
      padding: 15px;
      margin-top:10px;
    }

    .info {
      padding: 6px 8px;
      font: 14px/16px Arial, Helvetica, sans-serif;
      background: white;
      background: rgba(255,255,255,0.8);
      box-shadow: 0 0 15px rgba(0,0,0,0.2);
      border-radius: 5px;
    }
    .info h4 {
      margin: 0 0 5px;
      color: #777;
    }

    .legend {
      text-align: left;
      line-height: 18px;
      color: #555;
    }
    .legend i {
      width: 18px;
      height: 18px;
      float: left;
      margin-right: 8px;
      opacity: 0.7;
    }

    path.district {
      fill: lightgrey;
      /*stroke:lightgrey;*/
    }
    .selected {
      fill: red;
      /*stroke:lightgrey;*/
    }

    div.panel {
      background-color: #ffffff;
      margin-left: 25px;
      margin-right: 25px;
      padding: 15px;
      margin-top:10px;
    }
    .scrolling {
    height: 80px;
    overflow: auto;
    }

    #mapAndFilterDiv {
      width: inherit;
      height: 200px;
      display: table;
      /*margin-left: 25px;
      margin-right: 25px;
      padding: 15px;
      margin-top:10px;*/
    }
    #contextMap {
      display: table-cell;
    }
  </style>
  </head>



  <body>
  <div id="map"></div>
  <div id="dataPanel">
    <input id="dbfile" type="file"></input>
    <div id="mapAndFilterDiv">
      <div style="table-row">
        <div id="contextMap"></div>

        <div id="summary" class = "panel" style = "display: table-cell">
          <h4 id="title"> some result or something </h4>
          <table>
            <!--dynamically filled by d3 -->
          </table>
        </div>

        <table>
          <!--dynamically filled by d3 -->
        </table>
      </div>
    </div>
    <div id="projlist" class = "panel scrolling">
      <table>
        <!--dynamically filled by d3 -->
      </table>
    </div>
    <div id="projdetails" class = "panel scrolling">
      <table>
        <!--dynamically filled by d3 -->
      </table>
    </div>
  </div>

  <!--these includes create the variables districtData and taData -->
  <script type="text/javascript" src="district.geojson"></script>
  <script type="text/javascript" src="ta.geojson"></script>
  <script type="text/javascript">

  var mapboxAccessToken = "pk.eyJ1IjoiYndicm93biIsImEiOiJjaW0yOTM3NWUwNnZjODNrczkwdmpsdmdwIn0.Suenv51O4LhrgsjtEokp7A";
  var map = L.map('map').setView([-13.95, 33.7], 10); //L stands for 'Leaflet'
  var displayFeature; //global variable representing the District or TA being displayed
  var dbFileElm = document.getElementById('dbfile'); //HTML5 file reader (where you upload file)
  var db; //global variable representing sqlite database

  var testQuery1 = "select ActivityPts.projID as ID, count() as NumActivityPtsInDistrict, ActivityPts.districtName as District, Donor, ProjectName, Status, YearSigned, YearCompleted, CumulativeCommitment, CumulativeDisbursement, Type, AMPSector, AverageClimateAdaptationScore, OverallClimateAdaptationScore, FinalClimateAdaptationScore, GeoCodedActivities, CommitmentPerActivity, DisbursementPerActivity from ActivityPts left outer join AllProjects on ActivityPts.projID = AllProjects.projID where districtName like '";
  var testQuery2 = "' group by ActivityPts.projID, ActivityPts.districtName order by districtName desc";

  //gives table with district and total number of projects
  var testQuery3 = "select districtName, count() as FreqProjects from (select distinct projID, districtName from ActivityPts) group by districtName order by districtName asc"


  //grey tile layer from openstreetmap
  L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=' + mapboxAccessToken, {
      id: 'mapbox.light',
      attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, ' +
        '<a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, ' +
        'Imagery Â© <a href="http://mapbox.com">Mapbox</a>',
      id: 'mapbox.light'
  }).addTo(map);

  //creates color scale
  //TODO: MAKE MEANINGFUL COLORS
  function getColor(d) {
    return d > 18 ? '#800026' :
           d > 15  ? '#BD0026' :
           d > 12  ? '#E31A1C' :
           d > 9  ? '#FC4E2A' :
           d > 6   ? '#FD8D3C' :
           d > 3   ? '#FEB24C' :
           d > 0   ? '#FED976' :
                      '#FFEDA0';
  }

  //this function gets called once for each polygon on startup
  //and once each time a polygon's style needs to be reset
  //TODO: STYLE DIFFERENTLY?
  function style(feature) {
    return {
        fillColor: getColor(feature.properties.pk), //TODO: choose correct feature here
        weight: 2,
        opacity: 1,
        color: 'white',
        dashArray: '3',
        fillOpacity: 0.7
    };
  }

  //on zoom-end event. 9 is an arbitrary zoom level for showing TA vs District
  map.on("zoomend", function(e) {
    if (map.getZoom() >= 9) {
      taGeojson.addTo(map);
      map.removeLayer(districtGeojson);
    } else {
      districtGeojson.addTo(map);
      map.removeLayer(taGeojson);
    }
  });

  //this function only gets called ONCE per each TA ON STARTUP
  function onEachTA(feature, layer) {
    console.log("onEachTA called")
    layer.on({
        mouseover: highlightFeature,
        mouseout: resetHighlight,
        click: onClick
    });
  }

  //this function only gets called ONCE per each district ON STARTUP
  //this is where we're setting what functions get called on which events
  function onEachDistrict(feature, layer) {
    layer.on({
        mouseover: highlightFeature,
        mouseout: resetHighlight,
        click: onClick,
        dblclick: onDoubleClick
    })
  }

  //this function gets called on mouseover for each polygon
  function highlightFeature(e) {
    var layer = e.target;
    layer.setStyle({
        weight: 5,
        color: '#666',
        dashArray: '',
        fillOpacity: 0.7
    });
    layer.bringToFront();
  }

  //this function gets called on mouseout for each polygon
  function resetHighlight(e) {
    if (e.target) districtGeojson.resetStyle(e.target);
    else districtGeojson.resetStyle(e);
  }

  //called on click
  function onClick(e) {
    var feature = e.target.feature;
    displayFeature = feature;
    updateDataDisplay();
  }

  //called on double click
  function onDoubleClick(e) {
    if (!isTA(e)) {
      map.fitBounds(e.target.getBounds());
    }
    onClick(e);
  }

  //this function gets called whenever we need to change what's being
  //displayed on the side panel
  function updateDataDisplay() {
    var districtName;
    //checking whether we have a TA or district, and getting the enclosing district name
    if (displayFeature.properties.district) {
      districtName = displayFeature.properties.district;
    } else {
      districtName = displayFeature.properties.districtna;
    }

    //TODO: QUERY DIFFERENTLY FOR TAs!!!!!

    //highlight in context map
    //this first selection says: "select the html element with the id 'contextMap' (in this case a div),
    //then select all html path elements within that div, and give them the CSS class 'district'"
    d3.select("#contextMap").selectAll("path")
      .classed("district", true)
      .classed("selected", false);
    //this one says: "from that same div, select the element with the CSS class districtName,
    //and give it those particular CSS classes"
    //(when doing a selection, a period indicates CSS class, and a # indicates html id)
    d3.select("#contextMap").select("." + districtName.replace(' ',''))
      .classed("district", false)
      .classed("selected", true);

    //if sqlite database exists...
    if (db) {
      var query = testQuery1 + districtName + testQuery2;
      var result = db.exec(query); //runs a query and gets the results
      //console.log(result);

      //result is actually an array of results, but with only one element,
      //so we just access result[0]
      var columns = result[0].columns;

      var summary = {"activeProjs":
                        {name: "Number of projects" ,
                        stat: result[0].values.length},
                      "someOtherStat":
                        {name: "Some other stat",
                          stat: 42,
                        }};

      //make title
      var title = d3.select("#title"); //selecting html element with id 'title'
      //.text() is a method for a d3 selection that sets the text
      title.text(displayFeature.properties.district); //TODO: MAKE WORK FOR TA

      //populate table of summary stats for district
      var summaryTable = d3.select("#summary").select("table");
      var rows = summaryTable.selectAll("tr")
        .data(["activeProjs", "someOtherStat"]); //see below for an explanation of d3.data()
      rows.exit().remove();
      var row = rows.enter().append("tr");
      row.append("td").attr("class", "td1");
      row.append("td").attr("class", "td2");

      rows.select(".td1").text(function(d){return summary[d].name + ": ";});
      rows.select(".td2").text(function(d){return summary[d].stat;});

      //populate table of projects
      var index = columns.findIndex(function(e) {return e == "ProjectName";});
      if (index) {
        var projectTable = d3.select("#projlist").select("table");
        var rows = projectTable.selectAll("tr") //first select all rows in the table
          .data(result[0].values); //now we're trying to bind the data from result[0].values with the table rows we have
                                   //however, there isn't always going to be the same number of data points as existing table rows
        rows.exit().remove();      //this is where the exit set comes in. we say rows.exit() to grab all of the rows that
                                   //did not get matched with any data (this happens if there are more rows than data). then we call
                                   //.remove() to get rid of them (the actual html elements are removed!)
        var row = rows.enter().append("tr"); //but if we have MORE data than rows, we have to create new rows
                                             //so rows.enter() grabs all the data that did not get matched to a row
                                             //and for each one, we append a new table row (tr)
                                             //we create a variable out of it so that we can further edit the element we're appending
        row.append("td").attr("class", "td1"); //here we add a new td FOR EACH ROW with the CSS class "td1"

        //NOTE: at most one of the enter or exit sets will exist, but we deal with both beacuse either can happen

        //after dealing with enter and exit sets the way we did. rows now contains exactly the table rows that will be displayed
        //including ones that were matched with data and ones that were added

        rows.select(".td1").text(function(d){ //now for each row, we select its td, and set its text
          return d[index]; //the parameter passed to this function -- d -- is THE DATA THAT WAS BOUND TO EACH ROW !!! THIS IS THE COOL PART OF D3!!!!
        });

        //on click, update project details
        //d3 is also sick in that it lets us easily create handlers for events
        rows.on("click", function(data) { //again the parameter passed to this function -- data in this case -- is the data that has been bound to the row

          var projDetails = {"Donor": "Donor",
                              "ProjectName": "Project Name",
                              "YearSigned": "Year Signed",
                              "YearCompleted": "Year Complete",
                              "CumulativeCommitment": "Cumulative Commitment"};

          var projDetailTable = d3.select("#projdetails").select("table");
          var rows = projDetailTable.selectAll("tr").data(Object.keys(projDetails)); //Object.keys() returns an array of keys
          rows.exit().remove();  //since we know there is going to be the same number of data points each time, this is kind of unnecessary,
          var row = rows.enter().append("tr");  //but it's a good habit to get into
          row.append("td").attr("class", "td1");
          row.append("td").attr("class", "td2");

          rows.select(".td1").text(function(d) {return projDetails[d];});
          rows.select(".td2").text(function(d) {
            var index = columns.findIndex(function(e) {return e == d;});
            return data[index];
          })
        })
      }
    }
  }

  function isTA(e) {
    return e.target.feature.properties.districtna != null
  }

  //this gets called when a file is uploaded
  dbFileElm.onchange = function() {
      var f = dbFileElm.files[0];
      var r = new FileReader();
      r.onload = function() {
          var Uints = new Uint8Array(r.result);
          db = new SQL.Database(Uints);
      }
      r.readAsArrayBuffer(f);
  }

  //using leaflet's geoJson parser
  var districtGeojson = L.geoJson(districtData, {
    style: style,
    onEachFeature: onEachDistrict
  }).addTo(map);

  var taGeojson = L.geoJson(taData, {
    style: style,
    onEachFeature: onEachTA
  });

  //create reference/context map using d3
  var width = 80, height =200;
  var svg = d3.select("#contextMap")
      .append("svg")
      .attr({"width":width, "height":height});

  var projection = d3.geo.mercator()
			.center([34.3, -13.25])
			.scale(1200)
			.translate([(width) / 2, (height)/2]);

  var path = d3.geo.path()
     .projection(projection);

 svg.selectAll("path")
 .data(districtData.features)
 .enter()
 .append("path")
 .attr("d",path)
 .attr("class", function(d){return "district " + d.properties.district.replace(' ','')});


  </script>
  </body>



</html>
